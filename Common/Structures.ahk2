/************************************************************************
 * @description Various Structures used throughout
 * @file Structures.ahk2
 * @author Tom Wilkason
 * @date 2024/02/17
 * @version 0.0.0
 ***********************************************************************/

#Requires AutoHotkey >= v2.1-alpha.9
#include dllFactory.ahk2
/**** D A T A    T Y P E S
 *    i8, i16, i32 and i64 are signed integers, with i32 being 32-bit.
 *    u8, u16, u32 and u64 are unsigned integers, with u32 being 32-bit.
 *    iptr and uptr are integers; 32-bit when A_PtrSize = 4 and 64-bit when A_PtrSize = 8.
 *    f32 and f64 are floating-point numbers.
 *    TODO - add clone method using CopyMemory dll call
 * 
 */
;----------------------------------------------------------------------
; Custom Draw related structure passed in
;----------------------------------------------------------------------
;----------------------------------------------------------------------
; Adds ptr/size and ability to shift address for passed in structures
; NOTE - 2.1 Alpha 9 has the StructFromPtr command to allow dynmaic creation
; of the structure, so no need to have a recursive set function
;----------------------------------------------------------------------
Class baseStructure {
   __New() {
      ; Save base address for each class instance based on this
      this.__myBase := ObjGetDataPtr(this)
      this.__myStructures := Array()
      ; Save embedded structure names that have Ptr property in an array
      ; Idea is enum on array is faster than enum/check props (which there can be a lot)
      For p in this.Base.OwnProps()
         if (this.%p%.HasProp("__myStructures"))
            this.__myStructures.Push(p)
   }
   Size => ObjGetDataSize(this)
   ; Ptr Needed for the SendMessage call (Alpha 8)
   ; Also allows for recusrive shift in nested typed property classes
   Ptr {
      get => ObjGetDataPtr(this)
   }
   ; Object.Clone() does NOT make a copy of any structure data
   ; Make a copy of this class struct fields (data) and its nested struct field classes 
   ; Does NOT copy instance variable data, just the structure content.
   ; NOTE -The nested structures are NOT contiguous in memory, therefore each has to be cloned (I think they may be contiguous)
   ;       However, since ObjGetDataSize returns the size of the parent and children, the parent
   ;       Strutures will copy more memory than needed.
   ;       Good news is it doesn't seem to leak memory (blocks are reused and the extra memory is freed OK)
   DeepClone() {
      ; Create a new class instance
      cCopy := %this.__Class%()
      ; Debug(this.__Class " From Range:" ObjGetDataPtr(this) " to " ObjGetDataPtr(this) + ObjGetDataSize(this))
      ; Debug(this.__Class " To Range:" ObjGetDataPtr(cCopy) " to " ObjGetDataPtr(cCopy) + ObjGetDataSize(this))
      ; Copy over the struct field data
      DllCall("RtlCopyMemory","Ptr",ObjGetDataPtr(cCopy),"Ptr",ObjGetDataPtr(this),"Ptr",ObjGetDataSize(this))
      ; Recurse through each of the children classes struct fields
      for p in this.__myStructures {
         this.%p%.Clone()
      }
      return cCopy
   }
   ; Copy only the contents of a structure to a target the same size
   ; Does not recurse
   ; TODO - I think we don't need to recurse, structures should be contiguous if declared that way
   CopyTo(objTarget) {
      ; Don't necessarly need the propery names to match, but they have to be the same size
      if (ObjGetDataSize(this) > 0 AND ObjGetDataSize(objTarget) = ObjGetDataSize(this)) {
         DllCall("RtlCopyMemory", "Ptr", ObjGetDataPtr(objTarget), "Ptr", ObjGetDataPtr(this), "Ptr", ObjGetDataSize(this))
         for p in this.__myStructures {
            ; Target must have same structure names for this to work
            if (objTarget.HasOwnProp(p)) {
               this.%p%.CopyTo(objTarget.%p%)
            } else {
               Warning("Ignoring " this.__Class "." p " since it doesn't exist on target")
            }
         }
         Return 1
      } else  {
         Throw(ValueError("Object Size Mismatch on " this.__Class, -1, objTarget.__Class))
      }
   }
   DumpProperties(Desc) {
      debug(Desc)
      For p in this.Base.OwnProps() {
         If (p != "__Class") {
            If (this.%p%.HasMethod("DumpProperties"))
               this.%p%.DumpProperties(Desc "." p)
            Else
               Try debug(" " this.__Class "." p "=" this.%p%)

         }
         ; For t, v in this.base.GetOwnPropDesc(p).OwnProps() {
         ;    debug("   t=" t " IsObject=" (v is Object))
         ; }
      }
   }
}
/*

https://stackoverflow.com/questions/72243620/nmhdr-definition-conflict
typedef struct tagNMHDR { from winuser.h
  HWND     hwndFrom;
  UINT_PTR idFrom;
  UINT     code;
  nweed pad for next ptr
} NMHDR;

typedef struct tagNMCUSTOMDRAWINFO {
  NMHDR     hdr;
  DWORD     dwDrawStage;
  HDC       hdc;
  RECT      rc;
  DWORD_PTR dwItemSpec;
  UINT      uItemState;
  LPARAM    lItemlParam;
} NMCUSTOMDRAW, *LPNMCUSTOMDRAW;

typedef struct tagNMLVCUSTOMDRAW {
  NMCUSTOMDRAW nmcd;

  COLORREF     clrText;
  COLORREF     clrTextBk;
  int          iSubItem;
  DWORD        dwItemType;
  COLORREF     clrFace;
  int          iIconEffect;
  int          iIconPhase;
  int          iPartId;
  int          iStateId;
  RECT         rcText;
  UINT         uAlign;
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;
*/
;----------------------------------------------------------------------
; Complicated nested structures for listview custom drawing
;----------------------------------------------------------------------
Class stNMHDR extends baseStructure {
   hwndFrom: uptr ; A window handle to the control sending the message. cls.nmc.nmhdr.hwndFrom
   idFrom: uptr   ; An identifier of the control sending the message.
   code: u32      ; A notification code. (NM_CUSTOMDRAW = -12)
}
Class stNMCUSTOMDRAW extends baseStructure {
   nmhdr      : stNMHDR   ; adjusts for needed padding
   dwDrawStage: u32       ; Need to determine stage
   hdc        : uptr      ; Can use to select a font into to change it
   rc         : stRECT
   dwItemSpec : uptr      ; Need, Row Number (0 based)
   uItemState : u32       ; Need, to adjust state
   lItemlParam: uptr      ; Application Specific (unused)

}
;----------------------------------------------------------------------
; Top level class, handling shifting of internal classes
; Whole thing is 136 bytes on win64
; https://learn.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-nmlvcustomdraw
;----------------------------------------------------------------------
Class stNMLVCUSTOMDRAW extends baseStructure {
   nmc      : stNMCUSTOMDRAW
   clrText  : U32       ; Need, text foreground color
   clrTextBk: U32       ; Need, text background color
   iSubItem : i32       ; Need, Col, ignore the rest
   ; Control Version 6.0+ below, unused don't think they work here
   dwItemType : U32     ; DWORD that contains the type of the item to draw. This member can be one of the following values.
   clrFace    : U32     ; COLORREF value representing the color that will be used to display the face of an item.
   iIconEffect: I32     ; Value of type int that specifies the effect that is applied to an icon, such as Glow, Shadow, or Pulse. Non-Report view I think
   iIconPhase : I32
   iPartId    : I32
   iStateId   : I32
   rcText     : stRECT ; RECT that specifies the rectangle in which the text is to be drawn.
   uAlign     : U32
}
/*
typedef struct tagLVITEMA {
  UINT   mask;
  int    iItem;
  int    iSubItem;
  UINT   state;
  UINT   stateMask;
  LPSTR  pszText;
  int    cchTextMax;
  int    iImage;
  LPARAM lParam;
  int    iIndent;
  int    iGroupId;
  UINT   cColumns;
  PUINT  puColumns;
  int    *piColFmt;
  int    iGroup;
} LVITEMA, *LPLVITEMA;
*/
Class stLVITEM extends baseStructure {
  mask      : u32
  iItem     : I32
  iSubItem  : I32
  state     : u32
  stateMask : u32
  pszText   : uPtr
  cchTextMax: i32
  iImage    : i32
  lParam    : uptr
  iIndent   : i32
  iGroupId  : i32
  cColumns  : u32
  puColumns : uPtr
  piColFmt  : uPtr
  iGroup    : i32
}
;----------------------------------------------------------------------
; RECT structure
;----------------------------------------------------------------------
Class stRECT extends baseStructure {
   left  : i32
   top   : i32
   right : i32
   bottom: i32
   ; Helper properties
   width {
      get =>(this.right   - this.left)
      set {
         this.right := this.left + Value
      }
   }
   height {
      get =>(this.bottom - this.top)
      set {
         this.bottom := this.top + Value
      }
   }
   shift(x,y) {
      this.left += x
      this.right += x
      this.top += y
      this.bottom += y
   }
}
;----------------------------------------------------------------------
; X/Y mouse point
;----------------------------------------------------------------------
Class stPOINT extends baseStructure {
   x: i32
   y: i32
}
;----------------------------------------------------------------------
; Structure returned by listview hittest
;----------------------------------------------------------------------
Class LVHITTESTINFO extends baseStructure {
   Pos   : stPOINT
   flags : U32
   Row   : I32
   Col   : I32
   iGroup: I32
}
; class stMONITORINFO {
;    cbSize : i32 := ObjGetDataSize(this)
;    rcMonitor : stRECT
;    rcWork : stRECT
;    dwFlags : i32
; }
Class stMONITORINFOEX extends baseStructure {
   cbSize   : i32 := ObjGetDataSize(this)
   rcMonitor: stRECT
   rcWork   : stRECT
   dwFlags  : i32
   _name    : 64
   name => StrGet(this._name, 64)
}
; https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-display_devicea
; WCHAR is used since this is unicode
Class stDISPLAY_DEVICE extends baseStructure {
   cb           : i32 := ObjGetDataSize(this)
   _DeviceName  : 64
   _DeviceString: 256
   StateFlags   : u32   ; -> indicates if the device is connected to an active monitor DISPLAY_DEVICE_ACTIVE=0x001 & DISPLAY_DEVICE_PRIMARY_DEVICE=0x100
   _DeviceID    : 256
   _DeviceKey   : 256
   DeviceName   => StrGet(this._DeviceName, 64)    ; \\.\DISPLAY1
   DeviceString => StrGet(this._DeviceString, 256) ; NVIDIA GeForce GTX 1660 SUPER
   DeviceID     => StrGet(this._DeviceID, 256)     ; Not Used
   DeviceKey    => StrGet(this._DeviceKey, 256)    ; \Registry\Machine\System\CurrentControlSet\Control\Video\{8A695132-A9CE-11EE-A5F5-9C7BEF3D41D2}\0003
}
/*
typedef struct tagWINDOWPLACEMENT {
  UINT  length;
  UINT  flags;
  UINT  showCmd;
  POINT ptMinPosition;
  POINT ptMaxPosition;
  RECT  rcNormalPosition;
  RECT  rcDevice;
} WINDOWPLACEMENT;
https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-windowplacement
Uses workspace coordinates vs screen coordinates
*/

Class stWINDOWPLACEMENT extends baseStructure {
   length          : u32 := ObjGetDataSize(this)
   flags           : u32     ; The flags that control the position of the minimized window and the method by which the window is restored
   showCmd         : u32     ; The current show state of the window
   ptMinPosition   : stPOINT ; The coordinates of the window's upper-left corner when the window is minimized.
   ptMaxPosition   : stPOINT ; The coordinates of the window's upper-left corner when the window is maximized.
   rcNormalPosition: stRECT  ; The window's coordinates when the window is in the restored position.
   rcDevice        : stRECT
}
/*
typedef struct tagGUITHREADINFO {
   DWORD cbSize;
   DWORD flags;
   HWND  hwndActive;
   HWND  hwndFocus;
   HWND  hwndCapture;
   HWND  hwndMenuOwner;
   HWND  hwndMoveSize;
   HWND  hwndCaret;
   RECT  rcCaret;
 } GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;
*/
Class stGUITHREADINFO extends baseStructure {
   cbSize       : u32 := ObjGetDataSize(this)
   flags        : u32
   hwndActive   : uptr
   hwndFocus    : uptr
   hwndCapture  : uptr
   hwndMenuOwner: uptr
   hwndMoveSize : uptr
   hwndCaret    : uptr
   rcCaret      : stRECT
}
/*
HFONT CreateFontA(
  LONG lfHeight;
  LONG lfWidth;
  LONG lfEscapement;
  LONG lfOrientation;
  LONG lfWeight;
  BYTE lfItalic;
  BYTE lfUnderline;
  BYTE lfStrikeOut;
  BYTE lfCharSet;
  BYTE lfOutPrecision;
  BYTE lfClipPrecision;
  BYTE lfQuality;
  BYTE lfPitchAndFamily;
  CHAR lfFaceName[LF_FACESIZE]; );
  lfHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72); to convert points -> lfHeight
  PointSize := DllCall("MulDiv","int",PointSize,"int",GetDeviceCaps(hDC, LOGPIXELSY),"int",72)
*/
Class stHFONT extends baseStructure {
   cHeight        : i32
   cWidth         : i32
   cEscapement    : i32
   cOrientation   : i32
   cWeight        : i32
   bItalic        : u8
   bUnderline     : u8
   bStrikeOut     : u8
   iCharSet       : u8
   iOutPrecision  : u8
   iClipPrecision : u8
   iQuality       : u8
   iPitchAndFamily: u8
   _pszFaceName   : 32
   pszFaceName    => StrGet(this._pszFaceName, 32)
   ; Translate Points to char height
   calcCHeight(hdc, PointSize) {
      Static LOGPIXELSY := 90
      GetDeviceCaps := DllCall("GetDeviceCaps","Ptr",hdc,"Int", LOGPIXELSY)
      ; Multiplies two 32-bit values and then divides the 64-bit result 
      ; by a third 32-bit value. The final result is rounded to the nearest integer.
      Return -Round(PointSize * GetDeviceCaps / 72)
   }
}
/*
typedef struct tagMINMAXINFO {
   POINT ptReserved;
   POINT ptMaxSize;
   POINT ptMaxPosition;
   POINT ptMinTrackSize;
   POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;
*/

Class stMINMAXINFO extends baseStructure {
   ptReserved    : stPOINT
   ptMaxSize     : stPOINT
   ptMaxPosition : stPOINT
   ptMinTrackSize: stPOINT
   ptMaxTrackSize: stPOINT
}
